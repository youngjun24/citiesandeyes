<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>보이지 않는 도시들 - Cities and eyes 2</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <style>
    @font-face {
      font-family: 'BookkMyungjo-Bd';
      src: url('./BookkMyungjo-Bd.woff2') format('woff2');
      font-weight: 700;
      font-style: normal;
    }

    @font-face {
      font-family: 'BookkMyungjo-Lg';
      src: url('./BookkMyungjo_Light.woff') format('woff');
      font-weight: 400;
      font-style: normal;
    }

    html, body {
      margin: 0;
      padding: 0;
      overflow-x: hidden;           /* ✅ 글자 날아가도 가로 확장 방지 */
      background: linear-gradient(to bottom, #53a6ef 0%, #caebff 60%, #ff9b61 100%);
    }

    body {
      color: white;
      line-height: 1.6;
      min-height: 100vh;           /* ✅ 최소 높이 보장 */
      box-sizing: border-box;
    }

    .container {
      max-width: 80vw;             /* ✅ 좌우 여백 확보 */
      margin: 0 auto;
      padding: 5vw 0;
    }

    h1 {
      font-family: 'BookkMyungjo-Lg', serif;
      font-weight: 400;
      font-size: 4vw;
      margin-bottom: 1vw;
    }

    h2 {
      font-family: 'BookkMyungjo-Lg', serif;
      font-weight: 400;
      font-size: 4vw;
      margin-top: 0;
      margin-bottom: 6vw;
    }

    hr {
      border: none;
      height: 1px;
      background: repeating-linear-gradient(
        to right,
        rgba(255, 255, 255, 0.5),
        rgba(255, 255, 255, 0.5) 3px,
        transparent 8px,
        transparent 12px
      );
      margin: 2vw 0 6vw 0;
    }

    p {
      font-family: 'BookkMyungjo-Lg', serif;
      font-weight: 400;
      font-size: 4vw;
      margin: 0 0 4vw 0;
      /* 기본 p 태그는 초기에는 숨김 처리 (공간 유지) */
      opacity: 0;
      visibility: hidden; /* 스크린 리더 등에서도 접근성 제거 */
      transition: opacity 0.5s ease; /* 부드러운 전환 효과 */
    }

    /* .scatter p는 초기에도 보여야 하므로 재정의 */
    p.scatter {
      opacity: 1;
      visibility: visible;
      position: relative;
      overflow: visible;
      word-break: keep-all;
      transition: opacity 0.5s ease;
    }

    .scatter span {
      display: inline-block;
      will-change: transform, opacity;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>보이지 않는 도시들 –</h1>
    <h2>Cities and eyes 2</h2>
    <hr />
    <p class="main-body-p"> It is the mood of the beholder which gives the city of Zemrude its form.
    </p>
    <p class="scatter">
      If you go by whistling, your nose a-tilt behind the whistle, you will know it from below: window sills, flapping curtains, fountains. 
    </p>
    <p class="main-body-p"> If you walk along hanging your head, your nails dug into the palms of your
      hands, your gaze will be held on the ground, in the gutters, the manhole
      covers, the fish scales, wastepaper.
      
      You cannot say that one aspect of the city is truer than the other, but you hear of
      the upper Zemrude chiefly from those who remember it, as they sink into the lower
      Zemrude, following every day the same stretches of street and finding again each morning the
      ill-humor of the day before, encrusted at the foot of the walls. For everyone, sooner or later,
      the day comes when we bring our gaze down along the drainpipes and we can no longer detach it
      from the cobblestones. The reverse is not impossible, but it is more rare: and so we
      continue walking through Zemrude's streets with eyes now digging into the cellars, the
      foundations, the wells.
    </p>
  </div>

  <script>
    const scatterTarget = document.querySelector('.scatter');
    // .scatter 클래스가 아닌 모든 p 태그를 선택합니다. (일반 본문 텍스트)
    const mainBodyParagraphs = document.querySelectorAll('p:not(.scatter)'); 
    
    // scatter 텍스트를 span으로 분리하는 기존 로직 (초기화)
    const scatterTextContent = scatterTarget.textContent;
    scatterTarget.textContent = ''; // 원래 텍스트를 비워주고 span으로 채울 준비

    const scatterSpans = [];

    scatterTextContent.split('').forEach(char => {
      if (char === ' ') {
        scatterTarget.appendChild(document.createTextNode(' '));
      } else {
        const span = document.createElement('span');
        span.textContent = char;
        scatterTarget.appendChild(span);
        scatterSpans.push(span);
      }
    });

    let scattered = false; // scatter 텍스트가 흩어졌는지 추적하는 플래그

    function scatterTextWithGravity() {
      // 텍스트가 이미 흩어졌으면 다시 실행하지 않습니다.
      if (scattered) return;
      scattered = true;

      scatterSpans.forEach(span => {
        const angle = Math.random() * Math.PI * 2;
        const velocity = Math.random() * 200 + 100;
        const vx = Math.cos(angle) * velocity;
        const vy = Math.sin(angle) * velocity - 300;

        gsap.to(span, {
          x: `+=${vx}`,
          y: `+=${vy}`,
          opacity: 0,
          duration: 2,
          ease: "power4.in",
        });
      });
      // 흩어지는 효과가 발생한 후에는 deviceorientation 리스너를 제거합니다.
      // 이렇게 하지 않으면 폰을 다시 움직일 때마다 계속 흩어지려고 할 수 있습니다.
      window.removeEventListener('deviceorientation', handleOrientation);
    }

    function handleOrientation(event) {
      const beta = event.beta; // X축을 중심으로 한 기기 기울기 (앞뒤)
      
      // 베타 값이 null이 아니고, 폰을 아래로 내렸을 때 (화면이 위를 향할 때, beta < -20)
      if (beta !== null && beta < -20) {
        // 이전에 흩어진 텍스트를 되돌려야 할 경우 (선택 사항, 복잡도 증가)
        // 현재 로직은 한 번 흩어지면 유지되도록 합니다.
        // 만약 폰을 다시 올렸을 때 흩어진 텍스트가 원래대로 돌아오고
        // 본문이 사라지며 다시 초기 상태가 되려면 이 부분에 리셋 로직이 필요합니다.
        // 하지만 요청은 "나머지 js 로직은 전부 그대로 유지"이므로, 흩어진 후에는 유지됩니다.
        
        // 1. .scatter 텍스트를 흩어지게 만듭니다.
        scatterTextWithGravity();

        // 2. 나머지 본문 텍스트를 보이게 합니다.
        mainBodyParagraphs.forEach(p => {
          gsap.to(p, { opacity: 1, visibility: 'visible', duration: 0.5 });
        });

      } else { // 폰이 정상 위치 (혹은 위로 들었을 때)
        // 1. .scatter 텍스트가 흩어진 상태라면, 이를 되돌리는 시도를 합니다.
        //    (여기서는 흩어짐을 초기화하고 다시 원본 상태로 돌립니다)
        if (scattered) {
          scatterSpans.forEach(span => {
            // 초기 위치로 되돌리면서 투명도를 1로 만듭니다.
            gsap.to(span, { x: 0, y: 0, opacity: 1, duration: 0.5, ease: "power2.out" });
          });
          scattered = false; // 흩어짐 상태 해제

          // 흩어짐이 리셋되었으므로, 다시 deviceorientation 리스너를 추가하여
          // 다음 각도 변화에 반응하도록 합니다. (중복 추가 방지)
          if (window.DeviceOrientationEvent && !window.listenerAdded) {
              window.addEventListener('deviceorientation', handleOrientation);
              window.listenerAdded = true;
          }
        }
        // 2. 나머지 본문 텍스트를 숨깁니다.
        mainBodyParagraphs.forEach(p => {
          gsap.to(p, { opacity: 0, visibility: 'hidden', duration: 0.5 });
        });
      }
    }

    // 페이지 로드 시 deviceorientation 이벤트 리스너 추가
    if (window.DeviceOrientationEvent) {
      window.addEventListener('deviceorientation', handleOrientation);
      window.listenerAdded = true; // 리스너 추가 여부 플래그
    } else {
      console.log("Device orientation not supported.");
    }
  </script>
</body>
</html>
