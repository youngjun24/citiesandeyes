<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>보이지 않는 도시들 - Cities and eyes 2</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <style>
    @font-face {
      font-family: 'BookkMyungjo-Bd';
      src: url('./BookkMyungjo-Bd.woff2') format('woff2');
      font-weight: 700;
      font-style: normal;
    }

    @font-face {
      font-family: 'BookkMyungjo-Lg';
      src: url('./BookkMyungjo_Light.woff') format('woff');
      font-weight: 400;
      font-style: normal;
    }

    html, body {
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      background: linear-gradient(to bottom, #53a6ef 0%, #caebff 60%, #ff9b61 100%);
    }

    body {
      color: white;
      line-height: 1.6;
      min-height: 100vh;
      box-sizing: border-box;
    }

    .container {
      max-width: 80vw;
      margin: 0 auto;
      padding: 5vw 0;
    }

    h1 {
      font-family: 'BookkMyungjo-Lg', serif;
      font-weight: 400;
      font-size: 4vw;
      margin-bottom: 1vw;
    }

    h2 {
      font-family: 'BookkMyungjo-Lg', serif;
      font-weight: 400;
      font-size: 4vw;
      margin-top: 0;
      margin-bottom: 6vw;
    }

    hr {
      border: none;
      height: 1px;
      background: repeating-linear-gradient(
        to right,
        rgba(255, 255, 255, 0.5),
        rgba(255, 255, 255, 0.5) 3px,
        transparent 8px,
        transparent 12px
      );
      margin: 2vw 0 6vw 0;
    }

    p {
      font-family: 'BookkMyungjo-Lg', serif;
      font-weight: 400;
      font-size: 4vw;
      margin: 0 0 4vw 0;
      /* 초기에는 모든 p 태그를 투명하게 숨깁니다 (공간 유지) */
      opacity: 0;
      visibility: hidden; /* 스크린 리더 등에서도 접근성 제거 */
      transition: opacity 0.5s ease;
    }

    p.scatter {
      /* scatter 텍스트는 초기부터 보여야 하므로 재정의 */
      opacity: 1;
      visibility: visible;
      position: relative;
      overflow: visible;
      word-break: keep-all;
      transition: opacity 0.5s ease; /* transition 속성을 상속받도록 함 */
    }

    .scatter span {
      display: inline-block;
      will-change: transform, opacity;
      /* 초기 상태에서는 span들도 흩어지지 않은 상태로 보입니다 */
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>보이지 않는 도시들 –</h1>
    <h2>Cities and eyes 2</h2>
    <hr />
    <p class="main-text">
      It is the mood of the beholder which gives the city of Zemrude its form.
    </p>
    <p class="scatter">
      If you go by whistling, your nose a-tilt behind the whistle, you will know it from below: window sills, flapping curtains, fountains. 
    </p>
    <p class="main-text">
      If you walk along hanging your head, your nails dug into the palms of your
      hands, your gaze will be held on the ground, in the gutters, the manhole
      covers, the fish scales, wastepaper.
      
      You cannot say that one aspect of the city is truer than the other, but you hear of
      the upper Zemrude chiefly from those who remember it, as they sink into the lower
      Zemrude, following every day the same stretches of street and finding again each morning the
      ill-humor of the day before, encrusted at the foot of the walls. For everyone, sooner or later,
      the day comes when we bring our gaze down along the drainpipes and we can no longer detach it
      from the cobblestones. The reverse is not impossible, but it is more rare: and so we
      continue walking through Zemrude's streets with eyes now digging into the cellars, the
      foundations, the wells.
    </p>
  </div>

  <script>
    const scatterTarget = document.querySelector('.scatter');
    const mainTextParagraphs = document.querySelectorAll('p:not(.scatter)'); // scatter가 아닌 모든 p 태그
    
    // scatter 텍스트를 span으로 분리하는 기존 로직 (초기화)
    const scatterTextContent = scatterTarget.textContent;
    scatterTarget.textContent = ''; 

    const scatterSpans = [];
    scatterTextContent.split('').forEach(char => {
      if (char === ' ') {
        scatterTarget.appendChild(document.createTextNode(' '));
      } else {
        const span = document.createElement('span');
        span.textContent = char;
        scatterTarget.appendChild(span);
        scatterSpans.push(span);
      }
    });

    let scattered = false; // scatter 텍스트가 흩어졌는지 추적

    // scatter 텍스트를 흩어지게 하는 함수
    function scatterTextWithGravity() {
      if (scattered) return; // 이미 흩어졌다면 다시 실행하지 않음
      scattered = true;

      scatterSpans.forEach(span => {
        const angle = Math.random() * Math.PI * 2;
        const velocity = Math.random() * 200 + 100;
        const vx = Math.cos(angle) * velocity;
        const vy = Math.sin(angle) * velocity - 300;

        gsap.to(span, {
          x: `+=${vx}`,
          y: `+=${vy}`,
          opacity: 0,
          duration: 2,
          ease: "power4.in",
        });
      });
      // 흩어지는 효과가 발생한 후에는 deviceorientation 리스너를 제거하여 더 이상 흩어지지 않도록 합니다.
      window.removeEventListener('deviceorientation', handleOrientation);
    }

    function handleOrientation(event) {
      const beta = event.beta; // X축을 중심으로 한 기기 기울기 (앞뒤)
      
      // 폰을 위로 들어 화면이 아래를 볼 때 (베타 값이 음수)
      if (beta !== null && beta < -20) {
        // 나머지 본문 텍스트를 사라지게 합니다 (opacity만 0으로, 공간은 유지)
        mainTextParagraphs.forEach(p => {
          gsap.to(p, { opacity: 0, visibility: 'hidden', duration: 0.5 });
        });

        // scatter 텍스트는 흩어지게 만듭니다.
        scatterTextWithGravity();

      } else { // 폰이 정상 위치일 때
        // 나머지 본문 텍스트를 다시 보이게 합니다.
        mainTextParagraphs.forEach(p => {
          gsap.to(p, { opacity: 1, visibility: 'visible', duration: 0.5 });
        });

        // scatter 텍스트는 초기 상태 (흩어지지 않은 상태)로 돌아와야 합니다.
        // 이 부분은 현재 gsap.to로 흩어진 후에는 되돌리기 어렵습니다.
        // 만약 흩어진 후 되돌리는 효과도 원한다면, 각 span의 초기 위치를 저장하고
        // 다시 그 위치로 되돌리는 로직이 필요합니다.
        // 현재는 한 번 흩어지면 유지되는 방식입니다.
        // 만약 흩어짐을 초기화해야 한다면, 페이지 새로고침이 필요하거나
        // scatterSpans의 transform과 opacity를 초기값으로 리셋해야 합니다.
        if (scattered) {
          // 흩어진 텍스트를 되돌리는 로직 (선택 사항이며 복잡도 증가)
          scatterSpans.forEach(span => {
            gsap.to(span, { x: 0, y: 0, opacity: 1, duration: 0.5, ease: "power2.out" });
          });
          scattered = false; // 흩어짐 상태 해제
          // 다시 deviceorientation 리스너를 추가하여 폰 각도 변화에 반응하도록 합니다.
          if (window.DeviceOrientationEvent && !window.listenerAdded) { // 중복 추가 방지
              window.addEventListener('deviceorientation', handleOrientation);
              window.listenerAdded = true;
          }
        }
      }
    }

    // 초기 로드 시 main-text들은 숨겨진 상태로 유지됩니다.
    // CSS에서 기본적으로 opacity: 0, visibility: hidden 설정했으므로 별도 JS 처리 불필요.

    // deviceorientation 이벤트 리스너 추가
    if (window.DeviceOrientationEvent) {
      window.addEventListener('deviceorientation', handleOrientation);
      window.listenerAdded = true; // 리스너 추가 여부 플래그
    } else {
      console.log("Device orientation not supported.");
    }
  </script>
</body>
</html>
