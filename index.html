<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>보이지 않는 도시들 - Cities and eyes 2</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<style>
@font-face {
font-family: 'BookkMyungjo-Bd';
src: url('./BookkMyungjo-Bd.woff2') format('woff2');
font-weight: 700;
font-style: normal;
}

@font-face {
font-family: 'BookkMyungjo-Lg';
src: url('./BookkMyungjo_Light.woff') format('woff');
font-weight: 400;
font-style: normal;
}

html, body {
margin: 0;
padding: 0;
overflow-x: hidden;
background: linear-gradient(to bottom, #53a6ef 0%, #ff9b61 100%);
background-size: 100% 400%;
background-position: center 0%;
transition: background-position 0.2s ease-out;
}

body {
color: white;
line-height: 1.6;
min-height: 100vh;
box-sizing: border-box;
}

.container {
max-width: 80vw;
margin: 0 auto;
padding: 5vw 0;
}

h1 {
font-family: 'BookkMyungjo-Lg', serif;
font-weight: 400;
font-size: 4vw;
margin-bottom: 1vw;
}

h2 {
font-family: 'BookkMyungjo-Lg', serif;
font-weight: 400;
font-size: 8vw;
margin-top: 0;
margin-bottom: 6vw;
}

hr {
border: none;
height: 1px;
background: repeating-linear-gradient(
to right,
rgba(255, 255, 255, 0.5),
rgba(255, 255, 255, 0.5) 3px,
transparent 8px,
transparent 12px
);
margin: 2vw 0 6vw 0;
}

p {
font-family: 'BookkMyungjo-Lg', serif;
font-weight: 400;
font-size: 8vw;
margin: 0 0 4vw 0;
/* 초기 상태: scatter를 제외한 다른 p 태그는 숨김 */
opacity: 0;
visibility: hidden; /* 공간은 유지하되 보이지 않게 */
/* transition 속성은 이제 JS (GSAP)에서 직접 제어하므로 여기서는 제거해도 됩니다. */
/* visibility 전환은 GSAP onComplete 콜백에서 제어됩니다. */
}

/* scatter 클래스를 가진 p 태그는 초기에도 보이도록 오버라이드 */
p.scatter {
opacity: 1;
visibility: visible;
position: relative;
overflow: visible;
word-break: keep-all;
/* scatter span의 transform과 opacity는 JS에서 제어하므로 여기서는 그대로 둡니다. */
}

.scatter span {
display: inline-block;
will-change: transform, opacity;
}
</style>
</head>
<body>
<div class="container">
<h2>Cities and eyes 2</h2>
<hr />
<p>
It is the mood of the beholder which gives the city of Zemrude its form.
</p>
<p class="scatter">
If you go by whistling, your nose a-tilt behind the whistle, you will know it from below: window sills, flapping curtains, fountains.
</p>
<p>
If you walk along hanging your head, your nails dug into the palms of your
hands, your gaze will be held on the ground, in the gutters, the manhole
covers, the fish scales, wastepaper.

You cannot say that one aspect of the city is truer than the other, but you hear of
the upper Zemrude chiefly from those who remember it, as they sink into the lower
Zemrude, following every day the same stretches of street and finding again each morning the
ill-humor of the day before, encrusted at the foot of the walls. For everyone, sooner or later,
the day comes when we bring our gaze down along the drainpipes and we can no longer detach it
from the cobblestones. The reverse is not impossible, but it is more rare: and so we
continue walking through Zemrude's streets with eyes now digging into the cellars, the
foundations, the wells.
</p>
</div>

<script>
const target = document.querySelector('.scatter');
const text = target.textContent;
target.textContent = ''; // 텍스트를 span으로 분리하기 위해 비움

const spans = [];
text.split('').forEach(char => {
if (char === ' ') {
target.appendChild(document.createTextNode(' '));
} else {
const span = document.createElement('span');
span.textContent = char;
// 초기에는 모든 span이 원래 위치에 투명도 1로 보이도록 설정
gsap.set(span, { x: 0, y: 0, opacity: 1 });
target.appendChild(span);
spans.push(span);
}
});

const otherParagraphs = document.querySelectorAll('p:not(.scatter)');

let currentMode = "illusion"; // 초기 모드를 "illusion"으로 설정 (scatter만 보이는 상태)

// 텍스트를 흩어지게 하고 나머지 본문을 보이게 하는 함수 (원본 switchToReality 이름 유지)
function switchToReality() {
if (currentMode === "reality") return; // 이미 reality 상태면 아무것도 안함
currentMode = "reality";

spans.forEach(span => {
const angle = Math.random() * Math.PI * 2;
const velocity = Math.random() * 200 + 100;
const vx = Math.cos(angle) * velocity;
const vy = Math.sin(angle) * velocity - 300;

gsap.to(span, {
x: `+=${vx}`,
y: `+=${vy}`,
opacity: 0,
duration: 2,
ease: "power4.in",
});
});

// 본문 나타날 때는 visibility: 'visible'을 즉시 적용하고 opacity 애니메이션
otherParagraphs.forEach(p => {
    p.style.visibility = 'visible'; // 먼저 보이게 설정
    gsap.to(p, { opacity: 1, duration: 1, ease: "power2.out" });
});
}

// 텍스트를 원래대로 되돌리고 나머지 본문을 숨기는 함수 (원본 switchToIllusion 이름 유지)
function switchToIllusion() {
if (currentMode === "illusion") return; // 이미 illusion 상태면 아무것도 안함
currentMode = "illusion";

spans.forEach(span => {
gsap.to(span, {
x: 0,
y: 0,
opacity: 1,
duration: 2,
ease: "power2.out",
});
});

// ⭐ 수정된 부분: opacity 애니메이션이 완료된 후에 visibility를 hidden으로 설정합니다. ⭐
otherParagraphs.forEach(p => {
    gsap.to(p, {
        opacity: 0,
        duration: 1, // 1초 동안 opacity가 0으로 변합니다.
        ease: "power2.out", // 부드러운 사라짐을 위해 ease 추가 (선택 사항)
        onComplete: () => { // opacity 애니메이션이 완료된 후 실행될 콜백 함수
            p.style.visibility = 'hidden'; // 그제서야 visibility를 hidden으로 변경
        }
    });
});
}

function handleOrientation(event) {
const beta = event.beta;

// 배경 그라데이션 업데이트 로직 (원본 코드와 동일)
function updateGradient(beta) {
let normalized = (beta + 90) / 270;
normalized = Math.max(0, Math.min(1, normalized));

const position = 100 - normalized * 100;
document.body.style.backgroundPosition = `center ${position}%`;
}

if (beta !== null) {
updateGradient(beta);
// 폰을 아래로 내렸을 때 (화면이 위로 향할 때)
if (beta < 0) { // 원본 코드의 조건
  if (beta < 30) { // 원본 코드의 조건 (화면 위로 향할 때)
    switchToReality();
  }
}
// 폰을 위로 올렸을 때 (화면이 아래로 향할 때)
else if (beta > 120) { // 원본 코드의 조건 (화면 아래로 향할 때)
  switchToIllusion();
}
}
}

if (window.DeviceOrientationEvent) {
window.addEventListener('deviceorientation', handleOrientation);
}

// 페이지 로드 시 초기 상태를 설정합니다.
// 다른 P태그들을 숨깁니다.
// CSS에서 이미 opacity:0, visibility:hidden으로 초기 설정했으므로
// GSAP set을 사용하면 transition이 적용되지 않습니다.
// GSAP to를 사용하지 않으므로 CSS의 transition이 적용됩니다.
// 하지만 안전하게 JS로 초기화하는 것이 더 좋습니다.
otherParagraphs.forEach(p => {
    gsap.set(p, { opacity: 0, visibility: 'hidden' });
});

</script>
</body>
</html>
